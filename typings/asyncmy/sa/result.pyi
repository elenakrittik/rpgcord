"""
This type stub file was generated by pyright.
"""

from collections.abc import Mapping

async def create_result_proxy(connection, cursor, dialect, result_map): # -> ResultProxy:
    ...

class RowProxy(Mapping):
    __slots__ = ...
    def __init__(self, result_proxy, row, processors, keymap) -> None:
        """RowProxy objects are constructed by ResultProxy objects."""
        ...

    def __iter__(self):
        ...

    def __len__(self): # -> int:
        ...

    def __getitem__(self, key):
        ...

    def __getattr__(self, name):
        ...

    def __contains__(self, key):
        ...

    __hash__ = ...
    def __eq__(self, other) -> bool:
        ...

    def __ne__(self, other) -> bool:
        ...

    def as_tuple(self): # -> tuple[Unknown, ...]:
        ...

    def __repr__(self): # -> str:
        ...



class ResultMetaData:
    """Handle cursor.description, applying additional info from an execution
    context."""
    def __init__(self, result_proxy, metadata) -> None:
        ...



class ResultProxy:
    """Wraps a DB-API cursor object to provide easier access to row columns.

    Individual columns may be accessed by their integer position,
    case-insensitive column name, or by sqlalchemy schema.Column
    object. e.g.:

      row = fetchone()

      col1 = row[0]    # access via integer position

      col2 = row['col2']   # access via name

      col3 = row[mytable.c.mycol] # access via Column object.

    ResultProxy also handles post-processing of result column
    data using sqlalchemy TypeEngine objects, which are referenced from
    the originating SQL statement that produced this result set.
    """
    def __init__(self, connection, cursor, dialect, result_map) -> None:
        ...

    @property
    def dialect(self): # -> Unknown:
        """SQLAlchemy dialect."""
        ...

    @property
    def cursor(self): # -> Unknown | None:
        ...

    def keys(self): # -> tuple[Unknown, ...] | tuple[()]:
        """Return the current set of string keys for rows."""
        ...

    @property
    def rowcount(self):
        """Return the 'rowcount' for this result.

        The 'rowcount' reports the number of rows *matched*
        by the WHERE criterion of an UPDATE or DELETE statement.

        .. note::

           Notes regarding .rowcount:


           * This attribute returns the number of rows *matched*,
             which is not necessarily the same as the number of rows
             that were actually *modified* - an UPDATE statement, for example,
             may have no net change on a given row if the SET values
             given are the same as those present in the row already.
             Such a row would be matched but not modified.

           * .rowcount is *only* useful in conjunction
             with an UPDATE or DELETE statement.  Contrary to what the Python
             DBAPI says, it does *not* return the
             number of rows available from the results of a SELECT statement
             as DBAPIs cannot support this functionality when rows are
             unbuffered.

           * Statements that use RETURNING may not return a correct
             rowcount.
        """
        ...

    @property
    def lastrowid(self):
        """Returns the 'lastrowid' accessor on the DBAPI cursor.

        This is a DBAPI specific method and is only functional
        for those backends which support it, for statements
        where it is appropriate.
        """
        ...

    @property
    def returns_rows(self): # -> bool:
        """True if this ResultProxy returns rows.

        I.e. if it is legal to call the methods .fetchone(),
        .fetchmany() and .fetchall()`.
        """
        ...

    @property
    def closed(self): # -> bool:
        ...

    async def close(self): # -> None:
        """Close this ResultProxy.

        Closes the underlying DBAPI cursor corresponding to the execution.

        Note that any data cached within this ResultProxy is still available.
        For some types of results, this may include buffered rows.

        If this ResultProxy was generated from an implicit execution,
        the underlying Connection will also be closed (returns the
        underlying DBAPI connection to the connection pool.)

        This method is called automatically when:

        * all result rows are exhausted using the fetchXXX() methods.
        * cursor.description is None.
        """
        ...

    async def fetchall(self): # -> list[RowProxy] | None:
        """Fetch all rows, just like DB-API cursor.fetchall()."""
        ...

    async def fetchone(self): # -> RowProxy | None:
        """Fetch one row, just like DB-API cursor.fetchone().

        If a row is present, the cursor remains open after this is called.
        Else the cursor is automatically closed and None is returned.
        """
        ...

    async def fetchmany(self, size=...): # -> list[RowProxy] | None:
        """Fetch many rows, just like DB-API
        cursor.fetchmany(size=cursor.arraysize).

        If rows are present, the cursor remains open after this is called.
        Else the cursor is automatically closed and an empty list is returned.
        """
        ...

    async def first(self): # -> RowProxy | None:
        """Fetch the first row and then close the result set unconditionally.

        Returns None if no row is present.
        """
        ...

    async def scalar(self): # -> None:
        """Fetch the first column of the first row, and close the result set.

        Returns None if no row is present.
        """
        ...

    def __aiter__(self): # -> Self@ResultProxy:
        ...

    async def __anext__(self): # -> RowProxy:
        ...
